include/master-slave.inc
[connection master]
#
# Initialize test data
connection master;
create table t1 (a int primary key, b int) engine=innodb;
insert into t1 values (-1, 0);
include/save_master_gtid.inc
connection slave;
include/sync_with_master_gtid.inc
include/stop_slave.inc
set @save_debug= @@GLOBAL.debug_dbug;
set @save_par_thds= @@GLOBAL.slave_parallel_threads;
set @save_par_mode= @@GLOBAL.slave_parallel_mode;
set @@GLOBAL.slave_parallel_threads= 4;
set @@GLOBAL.slave_parallel_mode= optimistic;
set statement sql_log_bin=0 for call mtr.add_suppression("Commit failed due to failure of an earlier commit on which this one depends");
#
# Test Case 1: Ensure that a 2-phase XA transaction has its XA PREPARE
# and XA COMMIT run concurrently. That is, the XA COMMIT will wait at
# group commit until the XA PREPARE binlogs, and then it will wait again
# until the XA PREPARE finishes preparing in all engines. At this point,
# the XA COMMIT will run to completion.
connection master;
set @@session.gtid_seq_no= 100;
XA START 'x';
insert into t1 values (0, 0);
XA END 'x';
XA PREPARE 'x';
XA COMMIT 'x';
include/save_master_gtid.inc
connection slave;
set @@global.debug_dbug= "+d,hold_worker_on_schedule,stop_after_binlog_prepare";
include/start_slave.inc
# Waiting for XAP to pause when it is pulled from the queue
set debug_sync= "now wait_for reached_pause";
# Before the XA PREPARE executes, the XA COMMIT should wait in group commit..
# ..done
# Execute the XA PREPARE
set debug_sync= "now signal continue_worker";
# Wait for XA PREPARE to have binlogged, but hold it before it prepares in engines
set debug_sync= "now wait_for xa_prepare_binlogged";
# The XA COMMIT should move on from binlog to wait for the XA PREPARE to complete in engines
# ..done
# Signal the XAP to complete in engines (which will automatically signal XAC)
set debug_sync= "now signal continue_xap";
include/sync_with_master_gtid.inc
include/diff_tables.inc [master:test.t1, slave:test.t1]
connection slave;
include/stop_slave.inc
set @@global.debug_dbug= @save_debug;
#
# Test Case 2: If two XA transactions have different XIDs, ensure both
# phases of both transactions can all execute concurrently.
# Ensure slave is stopped
connection slave;
include/wait_for_slave_to_stop.inc
set @@global.debug_dbug= "+d,stop_after_binlog_prepare";
connection master;
XA START 'x1';
insert into t1 values (1, 0);
XA END 'x1';
XA PREPARE 'x1';
XA COMMIT 'x1';
XA START 'x2';
insert into t1 values (2, 0);
XA END 'x2';
XA PREPARE 'x2';
XA COMMIT 'x2';
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
# If two XA transactions have different XIDs, ensure both phases of both
# transactions all execute concurrently..
# ..done
# Verify XA PREPARE has binlogged
set debug_sync= "now wait_for xa_prepare_binlogged";
# Signal the XAPs to complete in engines (which will automatically signal XACs)
set debug_sync= "now signal continue_xap";
set debug_sync= "now signal continue_xap";
include/sync_with_master_gtid.inc
include/diff_tables.inc [master:test.t1, slave:test.t1]
connection slave;
include/stop_slave.inc
set @@global.debug_dbug= @save_debug;
#
# Test Case 3: Two current 2-phase XA transactions with matching XIDs
# should run one after the other, while each transaction still allows
# its XAC/XAP to run concurrently
# Ensure slave is stopped
connection slave;
include/wait_for_slave_to_stop.inc
set @@global.debug_dbug= "+d,stop_after_binlog_prepare,stop_after_binlog_commit_by_xid";
connection master;
XA START 'x';
insert into t1 values (3, 0);
XA END 'x';
XA PREPARE 'x';
XA COMMIT 'x';
XA START 'x';
insert into t1 values (4, 0);
XA END 'x';
XA PREPARE 'x';
XA COMMIT 'x';
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
# Ensure first XA transaction is running concurrently
# Ensure second XA transaction's XAP waits for the first transaction
# Verify first XA PREPARE has binlogged
set debug_sync= "now wait_for xa_prepare_binlogged";
# Signal first XA PREPARE to complete
set debug_sync= "now signal continue_xap";
# Wait for first XA COMMIT to binlog
set debug_sync= "now wait_for xa_commit_binlogged";
# Ensure second XA PREPARE doesn't begin yet because the XAC hadn't released its XID
# Signal first XA COMMIT to complete
set debug_sync= "now signal continue_xac";
# Wait for second XA PREPARE to binlogged
set debug_sync= "now wait_for xa_prepare_binlogged";
# Ensure second XA COMMIT is concurrent with XAP
# Signal second XA transaction to complete
set debug_sync= "now signal continue_xap";
set debug_sync= "now wait_for xa_commit_binlogged";
set debug_sync= "now signal continue_xac";
include/sync_with_master_gtid.inc
include/diff_tables.inc [master:test.t1, slave:test.t1]
connection slave;
include/stop_slave.inc
set @@global.debug_dbug= @save_debug;
#
# Test Case 4: Error Case. If an XAP errors while its XAC is waiting on
# it, both the XAP and XAC should rollback successfully. Note this tests
# both:
#    a) XAC is waiting in group commit (first phase times out in DMLs)
#    b) XAC is waiting in group commit, with another XAP with a
#       duplicate XID waiting on it.
# Case a)
# Ensure slave is stopped
connection slave;
include/wait_for_slave_to_stop.inc
set @save_lock_wait_timeout= @@GLOBAL.innodb_lock_wait_timeout;
set @save_trans_retries= @@GLOBAL.slave_transaction_retries;
set @@global.innodb_lock_wait_timeout= 1;
set @@global.slave_transaction_retries= 0;
connection master;
XA START 'x';
update t1 set b=b+1 where a=-1;
XA END 'x';
XA PREPARE 'x';
XA COMMIT 'x';
include/save_master_gtid.inc
connection slave1;
BEGIN;
select * from t1 where a=-1 for update;;
a	b
-1	0
connection slave;
include/start_slave.inc
include/wait_for_slave_sql_error.inc [errno=1205]
connection slave1;
ROLLBACK;
connection slave;
include/stop_slave_io.inc
set @@global.innodb_lock_wait_timeout= @save_lock_wait_timeout;
set @@global.slave_transaction_retries= @save_trans_retries;
# Ensure on slave restart, we can re-execute the XA transaction
include/start_slave.inc
include/save_master_gtid.inc
include/stop_slave.inc
set @@global.debug_dbug= @save_debug;
# Case b)
# Ensure slave is stopped
connection slave;
include/wait_for_slave_to_stop.inc
set @save_lock_wait_timeout= @@GLOBAL.innodb_lock_wait_timeout;
set @save_trans_retries= @@GLOBAL.slave_transaction_retries;
set @@global.innodb_lock_wait_timeout= 1;
set @@global.slave_transaction_retries= 0;
connection master;
XA START 'x';
update t1 set b=b+1 where a=-1;
XA END 'x';
XA PREPARE 'x';
XA COMMIT 'x';
XA START 'x';
insert into t1 values (5, 0);
XA END 'x';
XA PREPARE 'x';
XA COMMIT 'x';
include/save_master_gtid.inc
connection slave1;
BEGIN;
select * from t1 where a=-1 for update;;
a	b
-1	1
connection slave;
include/start_slave.inc
include/wait_for_slave_sql_error.inc [errno=1205]
connection slave1;
ROLLBACK;
# There should not be any prepared rows seen by XA RECOVER
XA RECOVER;
formatID	gtrid_length	bqual_length	data
# Ensuring data from second XAP isn't visible..
# ..done
connection slave;
include/stop_slave_io.inc
set @@global.innodb_lock_wait_timeout= @save_lock_wait_timeout;
set @@global.slave_transaction_retries= @save_trans_retries;
# Ensure on slave restart, we can re-execute the XA transaction
include/start_slave.inc
include/save_master_gtid.inc
include/stop_slave.inc
set @@global.debug_dbug= @save_debug;
include/start_slave.inc
# Ensuring data from second XAP is visible..
# ..done
#
# Cleanup
connection master;
DROP TABLE t1;
include/save_master_gtid.inc
connection slave;
include/sync_with_master_gtid.inc
include/stop_slave.inc
set @@GLOBAL.slave_parallel_threads= @save_par_thds;
set @@GLOBAL.slave_parallel_mode= @save_par_mode;
include/start_slave.inc
include/rpl_end.inc
# End of rpl_xa_concurrent_xap_xac.test
